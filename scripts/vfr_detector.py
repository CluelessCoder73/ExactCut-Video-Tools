# vfr_detector.py
# Standalone script to detect VFR in all *_frame_log.txt files in the current directory
# Now also flags "suspiciously small differences" (e.g., minor rounding errors)
# Tested and works with:
# - Python 3.13.2
# - "FFmpeg" generated frame log files (the version in LosslessCut 3.64.0)
"""
# ğŸ¥ `vfr_detector.py` â€” User Guide

**Purpose:**
This script scans all `*_frame_log.txt` files in the current directory to detect whether any videos were encoded using **Variable Frame Rate (VFR)**. It also flags files with **suspiciously small frame duration differences**, which are often falsely reported as VFR by tools like MediaInfo.

---

## âœ… What It Does

* Identifies **true VFR** by scanning all `duration_time:` values for each frame.
* Reports **how many unique frame durations** were found.
* Flags cases where differences are extremely small (within ~0.1%), which may be due to rounding.
* Writes the results to a file named:
  **`VFR_info.txt`**

---

## ğŸ” How It Works

### ğŸ”„ Frame Log Parsing

* The script **reads every frame** in each `*_frame_log.txt` file â€” **nothing is skipped**.
* It uses only lines containing:

  ```
  Parsed_showinfo_0
  ```

  (These lines are generated by FFmpeg when using the `showinfo` filter.)

### ğŸ“Š Duration Detection

* For every valid frame, it extracts the value after `duration_time:`.
* It collects **all unique durations**, rounded to **6 decimal places**.
* If more than one unique value is found, the video is flagged as **VFR**.

---

## âš ï¸ Suspiciously Small Differences

If the video has >1 unique duration, but the **longest and shortest durations differ by â‰¤ 0.1%**, the script adds a note like:

```
Note: Duration differences are extremely small (e.g., rounding artifacts).
```

This helps distinguish between **true VFR** and **CFR videos misreported** due to minor encoding quirks â€” especially common in videos trimmed by FFmpeg.

---

## ğŸ“ Example Output (`VFR_info.txt`)

```
my.video_1_frame_log.txt: VFR detected
    duration_time: 0.041667
    duration_time: 0.041625

my.video_2_frame_log.txt: Constant frame rate
    duration_time: 0.041708

# Summary
WARNING: One or more videos appear to use Variable Frame Rate (VFR).
Ensure duration-based cutlists are accurate for these.

Note: Some frame logs show very small duration variations that may be rounding errors.
These are flagged as 'suspiciously small differences' and may be safe to treat as CFR.
```

---

## ğŸ’¡ Use Case

This script is ideal for:

* Verifying source or exported videos before cutlist generation.
* Deciding whether to use **frame-based** (CFR-safe) or **duration-based** (VFR-friendly) cutlists.
* Confirming if MediaInfo is falsely reporting VFR due to rounding noise.

---

## ğŸ›  Requirements

* Python 3.x
* FFmpeg-generated `*_frame_log.txt` files using:

  ```
  ffmpeg -i input.mp4 -vf showinfo -f null - > yourvideo_frame_log.txt 2>&1
  ```

---

## ğŸ’¬ Questions Answered

**Q: Does it skip frames or take samples?**
**A:** No sampling is used â€” it scans **all frames** from the log for reliable accuracy.

**Q: Is the threshold adjustable?**
**A:** By default, the script uses a **0.1% difference threshold** to flag â€œsuspiciously smallâ€ differences. This threshold is appropriate for most use cases.

**Q: Does this replace MediaInfo?**
**A:** For cutlist reliability, **yes**. This script is more accurate than MediaInfo when checking true frame-by-frame behavior.
"""
import os
import re

def detect_vfr_in_log(file_path):
    durations = set()
    raw_durations = []
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                if 'Parsed_showinfo_0' in line:
                    match = re.search(r'duration_time:([\d.]+)', line)
                    if match:
                        dur = float(match.group(1))
                        raw_durations.append(dur)
                        durations.add(round(dur, 6))

        is_vfr = len(durations) > 1
        suspicious = False

        if is_vfr:
            min_dur = min(raw_durations)
            max_dur = max(raw_durations)
            if min_dur > 0 and (max_dur / min_dur) <= 1.001:
                suspicious = True

        return is_vfr, suspicious, sorted(set(round(d, 6) for d in raw_durations))
    except Exception as e:
        return False, False, [f"Error reading file: {e}"]

def main():
    current_dir = os.getcwd()
    log_files = [f for f in os.listdir(current_dir) if f.endswith('_frame_log.txt')]
    report_lines = []
    any_vfr = False
    any_suspicious = False

    for log_file in sorted(log_files):
        full_path = os.path.join(current_dir, log_file)
        is_vfr, suspicious, duration_list = detect_vfr_in_log(full_path)

        if is_vfr:
            any_vfr = True
        if suspicious:
            any_suspicious = True

        if is_vfr:
            if suspicious:
                status = "VFR detected (small variation â€” possibly CFR)"
            else:
                status = "VFR detected"
        else:
            status = "Constant frame rate"

        report_lines.append(f"{log_file}: {status}")
        for dur in duration_list:
            report_lines.append(f"    duration_time: {dur}")
        report_lines.append("")

    report_lines.append("# Summary")
    if any_vfr:
        report_lines.append("WARNING: One or more videos appear to use Variable Frame Rate (VFR).")
        report_lines.append("Ensure duration-based cutlists are accurate for these.")
        if any_suspicious:
            report_lines.append("Note: Some logs show very small variations that may be rounding errors.")
            report_lines.append("These are flagged as 'small variation â€” possibly CFR'.")
    else:
        report_lines.append("Frame rate mode for all videos: Constant")

    with open("VFR_info.txt", 'w', encoding='utf-8') as out:
        out.write("\n".join(report_lines))

    print("VFR detection complete. Results written to VFR_info.txt")

if __name__ == "__main__":
    main()
